import numpy as np
from cca_zoo.models import rCCA

class ORCCA():
    
    def __init__(self,view1,view2,width1,width2=None):
        
        self.Data1 = view1
        self.Data2 = view2
        self.width1 = width1
        
        if width2 is None:
            self.width2 = width1
        else:
            self.width2 = width2
        
        
    def random_features(self,m):
        
        """
        data: 2-D array
        Output: 2-D array
        """
        dim1 = self.Data1.shape[1]
        dim2 = self.Data2.shape[1]
        Gauss1 = np.random.normal(0,scale=1/self.width1,size = (dim1,m))
        Gauss2 = np.random.normal(0,scale=1/self.width1,size = (dim2,m))
        uni1 = np.random.uniform(high=2*np.pi,size = m).reshape((1,-1))
        uni2 = np.random.uniform(high=2*np.pi,size = m).reshape((1,-1))
        
        return Gauss1, Gauss2, uni1, uni2
    
    def Transform(self,Gauss1,Gauss2,uni1,uni2):
        
        """
        Gauss1,Gauss2: Gaussian features, 2-D array
        uni1,uni2: uniform features, 2-D row array
        Output: transformed data matrix, 2-D array
        """
        
        return np.cos(self.Data1@Gauss1+np.tile(uni1,(np.shape(self.Data1)[0],1))), np.cos(self.Data2@Gauss2+np.tile(uni2,(np.shape(self.Data2)[0],1)))
    
    def feature_selection(self,Gauss1,Gauss2,uni1,uni2,m,regular=None):
        
        """
        view1,view2: transformed data matrices, 2-D array with same shape
        reg: regularizer, float
        Output: selected features from feature pool, 2-D arrays
        """
        
        if regular is None:
            reg = 0    
        else:
            reg = regular
            
        if not Gauss1.shape[1] == Gauss2.shape[1]:
            
            raise ValueError("Make sure both view has the same number of random features")
        
        M0 = Gauss1.shape[1]
        
        phix,phiy = self.Transform(Gauss1,Gauss2,uni1,uni2)
        
        P_x = np.linalg.inv(reg*np.identity(M0) + np.dot(phix.T,phix))
        P_x = P_x@phix.T@phiy
        P_y = np.linalg.inv(reg*np.identity(M0) + phiy.T@phiy)
        P_y = P_y@phiy.T@phix
        qx = np.diagonal(P_x@P_y)
        qy = np.diagonal(P_y@P_x)
        index_1 = np.argsort(-qx)[:m]
        index_2 = np.argsort(-qy)[:m]
        
        return Gauss1[:,index_1],Gauss2[:,index_2],uni1[:,index_1], uni2[:,index_2]
    
    def ORCCA_mapping(self,m,M=None,regular=None):
        
        """
        Return the random feature mappings generated by ORCCA
        m:int
        """
        
        if M is None:
            M0 = 10*m
        else:
            M0 = M
        
        if regular is None:
            reg = 0    
        else:
            reg = regular
        
        Gauss1,Gauss2,uni1,uni2 = self.random_features(M0)
        Gauss1,Gauss2,uni1,uni2 = self.feature_selection(Gauss1,Gauss2,uni1,uni2,m,regular=reg)
        
        return self.Transform(Gauss1,Gauss2,uni1,uni2)
    
    def ORCCA_cor(self,m,M=None,regular = None):
        
        """
        Return the canonical correlations generated by ORCCA
        """
        
        X,Y = self.ORCCA_mapping(m,M,regular)
        
        if regular is None:
            reg = 0    
        else:
            reg = regular
        
        linear_cca = rCCA(latent_dims=m,c=reg)
        linear_cca.fit([X, Y])
        
        return linear_cca.score([X,Y])
        
        